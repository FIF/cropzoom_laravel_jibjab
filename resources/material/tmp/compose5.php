<?php
     /*******************************************************************************
     * Sample compose a face to a video.
     *********************************************************************************
     * Sample video has 30s long and in 1280x720 resolution 30fps.
     * For faster render (sample), i resize it to 800x450
     *********************************************************************************
     * Dependencies
     * FFMPEG
     * PHP
     * ImageMagick
     * 
     ***********************************************************************************
     * The simple method is that we cut video to frames first (using FFMPEG), e.g. 30s video
     * x 30FPS = 900 frames. 
     * Then we use ImageMagick to combine USER uploaded face to each frame
     * Finally re-compose result video from new frame with user face merged.
     *
     * Not all frame has face to replace, so we device video to several part for faster process.
     * This is depend on each video, this sample video has 4 part that contain frame have to replace.
     * Only about 220 out of total 900 frames have to replace faces.
     * 
     * In a 30s sample video, there are not all frame have face to replace. So I divide/cut
     * video to some part.
     *
     ********************************************************************************
     * TODOs 
     * Refactoring code, object, long methods... [see Martin Fowler Refactoring]
     * Remove hard code, magic number
     ****************************************************************************************
     * Drawbacks
     * Using this way is require many resource (CPU/memory...). For a 8 cores, 8-16GB memory AWS instances
     * there are about 10 concurrent video (users) render could be posible. If more than that it may be slaw and timed out.
     * 
     * As I known, JibJab use a technique like Flash. And each video has a different and manually proccess first.
     * Deepfake require a lot of computing power and huge of a user face for AI training.
     *****************************************************************************************
     * Notes
     * At the time of 2014 FFMPEG has an issue on multi-thread, so we should disable this feature on server. 
     * Need figure out does it fixxed on lastest FFMPEG version.
     */

    // Motion traking data, generated by Adobe After Effect and many manual process.
    // The transform data contain position (x, y) and the rotation angle of the face in each frames.
    // The angle is stored in degree instead of decimal redian number.
    $source = 'Transform_data.xml';

    $xmlstr = file_get_contents($source);
    $xmlcont = @simplexml_load_string($xmlstr); 

    $bg = new ImagickPixel('none');
    // Pass a face file name (in sample face directory)
    // accept Face_1 to Face_11 
    $face_name = $_GET['face_name'];  
    $face_dir = basename($face_name, ".png"); 
    new_working_dir($face_dir);

    $face = new Imagick();

    // I put sample faces to this directory.
    $face->readImage("./faces/".$face_name);
    $face->resizeImage(191,232,imagick::FILTER_LANCZOS,1);
    $face_w = $face->getimagewidth();
    $face_h = $face->getimageHeight();

    // For faster render, we use frame width 800 instead of 1280. Original video is 1280x720
    const $800_1280_ratio = 0.625; // 800/1280


    $start = time();
    
    // TODO refactoring 
    // For this sample video, I devide 30s long video to 4 part that contain frame have to replace face.
    // The other frames do not have to replace face, so let these part as video format.
    // After replace face and compose video, we finally has 
    foreach($xmlcont as $frame) 
    {
        if((intval($frame->time) >= 44) && (intval($frame->time) <= 79)) { // part1
            $imgFace = clone $face;

            // TODO remove Magic number
            // 2.42 is scale ratio caused by sample face image size used in Adobe After Effect and sample face in CropZoom
            // when crop user upload image 
            $imgFace = transform(-2, 2.42*$face_w * 800_1280_ratio, 2.42*$face_h * 800_1280_ratio, $imgFace);

            // $face = new Imagick("RESULT/frame_0".$frame->time. ".png");
            $frm = new Imagick("frames_800/frame_0".$frame->time. ".png");
            $frm->compositeImage($imgFace, imagick::COMPOSITE_DSTOVER, intval($frame->x +92.4 -241), intval($frame->y -20.8 -277)); 
            $img_outp = $face_dir."/frame_0". $frame->time. ".png";
            $frm->writeImage(''.$img_outp); 
        } 
        
        else if((intval($frame->time) >= 80) && (intval($frame->time) <= 125)) { // part2
            $imgFace = clone $face;
            $imgFace = transform(-2, 2.42*$face_w, 2.42*$face_h, $imgFace);
            $frm = new Imagick("frames_800/frame_0".$frame->time. ".png");
            // $face = new Imagick("RESULT/frame_0".$frame->time. ".png");
            $frm->compositeImage($imgFace, imagick::COMPOSITE_DSTOVER, intval($frame->x +62 -241), intval($frame->y -32.3 -277)); 
            $img_outp = $face_dir."/frame_0". $frame->time. ".png";
            $frm->writeImage(''.$img_outp); 
        } else if((intval($frame->time) >= 132) && (intval($frame->time) <= 196)) { // part3  132 (196)
            $anchor_x = 43.7;
            $anchor_y = 56.6;

            $x_zoom = $frame->scl_x/100;
            $y_zoom = $frame->scl_y/100;
            $scl_x = floatval($x_zoom)*36.2/100 * $face_w;
            $scl_y = floatval($y_zoom)*39.5/100 * $face_h;
            $scl_d = sqrt($scl_x*$scl_x/4 + $scl_y*$scl_y/4);

            $scl_D = sqrt($anchor_x*$anchor_x*$x_zoom*$x_zoom + $anchor_y*$anchor_y*$y_zoom*$y_zoom);
            $diameter = abs($scl_D - $scl_d);   // 

            $base_angle = atan($scl_y/$scl_x);
            $base_img_rotate = 0/180 *pi(); // Caused by when generate data from AE
            $rt = floatval($frame->rt)/180 *pi();
            $delta_rot = $base_angle + $rt + $base_img_rotate;

            $delta_x = $diameter * cos($delta_rot);
            $delta_y = $diameter * sin($delta_rot);

            $new_anchor_x = $frame->x + $delta_x;  // anchor point is in center of face image
            $new_anchor_y = $frame->y + $delta_y;  


            $imgFace = clone $face;
            $imgFace = transform(floatval($frame->rt), $scl_x, $scl_y, $imgFace);
            $shift_x = sin($frame->rt/180 * pi()) *$scl_y;  // X pos shift caused by rotate
            $shift_y = sin($frame->rt/180 * pi()) *$scl_x;

            $imgBG = new Imagick("frames_800/frame_0".$frame->time. ".png");
            if($frame->rt > 0) {
                $imgBG->compositeImage($imgFace, imagick::COMPOSITE_DSTOVER, intval($new_anchor_x-$shift_x), intval($new_anchor_y)); 
            } else {
                $imgBG->compositeImage($imgFace, imagick::COMPOSITE_DSTOVER, intval($new_anchor_x), intval($new_anchor_y +$shift_y)); 
            }
            $img_outp = $face_dir."/frame_0". $frame->time. ".png";
            $imgBG->writeImage(''.$img_outp); 
        } else if((intval($frame->time) >= 377) && (intval($frame->time) <= 455)) { // part4
            $x_zoom = $frame->scl_x/100;
            $y_zoom = $frame->scl_y/100;
            $scl_x = floatval($x_zoom)*36.2/100 * $face_w;
            $scl_y = floatval($y_zoom)*39.5/100 * $face_h;
            $scl_d = sqrt($scl_x*$scl_x/4 + $scl_y*$scl_y/4);
            $diameter = $scl_d;

            $base_angle = atan($scl_y/$scl_x);
            $rt = floatval($frame->rt)/180 *pi();
            $delta_rot = $base_angle + $rt;

            $delta_x = $diameter * cos($delta_rot);
            $delta_y = $diameter * sin($delta_rot);

            $new_anchor_x = $frame->x - $delta_x;  // anchor point is in center of face image
            $new_anchor_y = $frame->y - $delta_y;  

            $imgFace = clone $face;
            $imgFace = transform(floatval($frame->rt), $scl_x, $scl_y, $imgFace); //floatval($frame->rt)
            $shift_x = sin($frame->rt/180 * pi()) *$scl_y;  // X pos shift caused by rotate
            $shift_y = sin($frame->rt/180 * pi()) *$scl_x;

            $imgBG = new Imagick("frames_800/frame_0".$frame->time. ".png");

            if($frame->rt > 0) {
                $imgBG->compositeImage($imgFace, imagick::COMPOSITE_DSTOVER, intval($new_anchor_x-$shift_x+5), intval($new_anchor_y-5)); 
            } else {
                $imgBG->compositeImage($imgFace, imagick::COMPOSITE_DSTOVER, intval($new_anchor_x+5), intval($new_anchor_y +$shift_y-5)); 
            }
            $img_outp = $face_dir."/frame_0". $frame->time. ".png";
            $imgBG->writeImage(''.$img_outp); 
        }
        

    }
    
    
    compose($face_dir);
    // exec("/opt/local/bin/ffmpeg -framerate 30 -i RST/frame_0%03d.png -s:v 1280x720 -c:v libx264 -profile:v high -crf 23 -pix_fmt yuv420p -r 30 -vb 12M  RST/movies_2.mp4 2>&1", $o, $v);
    $end = time();
    echo " <br/> Time: ". ($end -$start). "<br/>";
    echo $end;

    function transform($rotate, $scale_x, $scale_y, $face) {
        $scale_x = intval($scale_x);          
        $scale_y = intval($scale_y);

        $bg = new ImagickPixel('none');
        // $imgFace = $face;
        $face->scaleImage($scale_x, $scale_y, false);
        $face->rotateImage($bg, $rotate); 
        return $face;
    }
    function compose($face_dir) {
        $name = rand(1, 99999);
        // Copy buffer frame (not have face to replace) merged with procced one to form coninuos frames video.
        exec("cp -r ./buffer_800/*.png $face_dir/ 2>&1", $out, $log);
        print_r($out);
        exec("/opt/local/bin/ffmpeg -framerate 30 -i $face_dir/frame_0%03d.png -s:v 800x450 -c:v libx264 -profile:v high -crf 23 -pix_fmt yuv420p -r 30 -vb 12M  $face_dir/movies_$name.mp4 1>&2", $o, $v);
        exec("/opt/local/bin/ffmpeg -i $face_dir/movies_$name.mp4 -c copy -bsf:v h264_mp4toannexb -f mpegts $face_dir.ts", $o2, $v2);
        print_r($v2);

        // Merge face-replaced video with other parts to form lastest video has same length.
        // Here we merge 3 part
        exec("/opt/local/bin/ffmpeg -i \"concat:intermediate1.ts|$face_dir.ts|intermediate3.ts\" -c copy -bsf:a aac_adtstoasc output_$name.mp4", $o3, $v3);
        exec("rm -rf $face_dir/");
        exec("/opt/local/bin/ffmpeg -i output_$name.mp4 -i audio.mp3  -strict -2 Final_$name.mp4", $out_aud, $v_aud);
        print_r($out_aud);
        print_r($o3);

        echo "Done !";
        echo "<a href='Final_$name.mp4'>Movie</a>";
        print_r($o);
        print_r($v);

        // ghep movie part 1
        // return video
    }
    function add_buffer_frame($face_dir) {
        exec("cp -r low_buffer/* $face_dir 2>&1", $o, $v);
    }
    function new_working_dir($dir_name) {
        exec("mkdir -p $dir_name 2>&1", $o, $v);
        print_r($o);
    }

?>
